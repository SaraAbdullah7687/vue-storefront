import express from 'express';
import cookieParser from 'cookie-parser';
import cors from 'cors';
import consola from 'consola';
import helmet from 'helmet';
import { Logger } from '@vue-storefront/core';

/**
 * Resolves dependencies based on the current working directory, not relative to this package.
 */
function resolveDependency(name) {
    try {
        const path = require.resolve(name, { paths: [process.cwd()] });
        // eslint-disable-next-line global-require
        return require(path);
    }
    catch (error) {
        Logger.error(error);
        throw new Error(`Could not resolve integration "${name}". See the error above for more details.`);
    }
}
function createRawExtensions(apiClient, integration) {
    const extensionsCreateFn = integration.extensions;
    const predefinedExtensions = apiClient.createApiClient._predefinedExtensions;
    return extensionsCreateFn ? extensionsCreateFn(predefinedExtensions) : predefinedExtensions;
}
function lookUpExternal(extension) {
    return typeof extension === 'string' ? resolveDependency(extension) : [extension];
}
function createExtensions(rawExtensions) {
    return rawExtensions.reduce((prev, curr) => [...prev, ...lookUpExternal(curr)], []);
}
async function getInitConfig({ apiClient, tag, integration }) {
    if (apiClient === null || apiClient === void 0 ? void 0 : apiClient.init) {
        try {
            consola.success(`- Integration: ${tag} init function Start!`);
            const initConfig = await (apiClient === null || apiClient === void 0 ? void 0 : apiClient.init(integration.configuration));
            consola.success(`- Integration: ${tag} init function Done!`);
            return initConfig;
        }
        catch (error) {
            throw Error(`Error during executing init function in ${tag} integration. Error message: ${error}`);
        }
    }
    return {};
}
async function registerIntegrations(app, integrations) {
    return await Object.entries(integrations).reduce(async (prevAsync, [tag, integration]) => {
        consola.info(`- Loading: ${tag} ${integration.location}`);
        const prev = await prevAsync;
        const apiClient = resolveDependency(integration.location);
        const rawExtensions = createRawExtensions(apiClient, integration);
        const extensions = createExtensions(rawExtensions);
        const initConfig = await getInitConfig({ apiClient, integration, tag });
        extensions.forEach(({ name, extendApp }) => {
            consola.info(`- Loading: ${tag} extension: ${name}`);
            if (extendApp) {
                extendApp({ app, configuration: integration.configuration });
            }
        });
        consola.success(`- Integration: ${tag} loaded!`);
        return {
            ...prev,
            [tag]: {
                apiClient,
                extensions,
                initConfig,
                configuration: integration.configuration,
                customQueries: integration.customQueries
            }
        };
    }, Promise.resolve({}));
}

const STATUS_FIELDS = ['status', 'statusCode'];
function reduceStatus(narrowObject, depth) {
    return function (statusCode, c) {
        if (statusCode) {
            return statusCode;
        }
        if (STATUS_FIELDS.includes(c)) {
            return narrowObject[c];
        }
        const newDepth = depth + 1;
        return obtainStatusCode(narrowObject[c], newDepth);
    };
}
function obtainStatusCode(givenObject, depth = 1) {
    const obj = givenObject || {};
    if (depth > 3) {
        return;
    }
    return Object.keys(obj).reduce(reduceStatus(obj, depth), null);
}
function getAxiosStatusCode(error) {
    if (error === null || error === void 0 ? void 0 : error.isAxiosError) {
        return error.response.status;
    }
}
function getApolloStatusCode(error) {
    if (error === null || error === void 0 ? void 0 : error.networkError) {
        return 500;
    }
    if (error === null || error === void 0 ? void 0 : error.code) {
        return typeof error.code === 'string' ? 400 : error.code;
    }
}
function getAgnosticStatusCode(error) {
    return getAxiosStatusCode(error) ||
        getApolloStatusCode(error) ||
        obtainStatusCode(error) ||
        200;
}

const app = express();
app.use(express.json());
app.use(cookieParser());
app.use(cors());
app.disable('x-powered-by');
async function createServer(config) {
    consola.info('Middleware starting....');
    const options = {
        contentSecurityPolicy: false,
        crossOriginOpenerPolicy: false,
        crossOriginEmbedderPolicy: false,
        permittedCrossDomainPolicies: {
            permittedPolicies: 'none'
        },
        ...(config.helmet || {})
    };
    const isHelmetEnabled = config.helmet === true || (config.helmet && Object.keys(config.helmet).length > 0);
    if (isHelmetEnabled) {
        app.use(helmet(options));
        consola.info('VSF `Helmet` middleware added');
    }
    consola.info('Loading integrations...');
    const integrations = await registerIntegrations(app, config.integrations);
    consola.success('Integrations loaded!');
    app.post('/:integrationName/:functionName', async (req, res) => {
        const { integrationName, functionName } = req.params;
        if (!integrations[integrationName]) {
            const errMsg = `"${integrationName}" integration is not configured. Please, check the request path or integration configuration.`;
            res.status(404);
            res.send(errMsg);
            return;
        }
        const { apiClient, configuration, extensions, customQueries, initConfig } = integrations[integrationName];
        const middlewareContext = { req, res, extensions, customQueries };
        const createApiClient = apiClient.createApiClient.bind({ middleware: middlewareContext });
        const apiClientInstance = createApiClient({ ...configuration, ...initConfig });
        const apiFunction = apiClientInstance.api[functionName];
        try {
            if (!(Symbol.iterator in Object(req.body)))
                req.body = [req.body];
            const platformResponse = await apiFunction(...req.body);
            res.send(platformResponse);
        }
        catch (error) {
            res.status(getAgnosticStatusCode(error));
            res.send(error);
        }
    });
    consola.success('Middleware created!');
    return app;
}

export { createServer };
//# sourceMappingURL=index.es.js.map
