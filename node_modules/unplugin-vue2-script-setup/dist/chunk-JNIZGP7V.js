"use strict";Object.defineProperty(exports, "__esModule", {value: true}); function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }


var _chunkIEW4T7YPjs = require('./chunk-IEW4T7YP.js');

// src/index.ts
var _unplugin = require('unplugin');
var _pluginutils = require('@rollup/pluginutils');

// src/core/transform.ts
var _magicstring = require('magic-string'); var _magicstring2 = _interopRequireDefault(_magicstring);
var _reftransform = require('@vue/ref-transform');

// src/core/parseSFC.ts
var _htmlparser2 = require('htmlparser2');
var _shared = require('@vue/shared');

// src/core/identifiers.ts
function getIdentifierDeclarations(nodes, identifiers = new Set()) {
  for (let node of nodes) {
    if (node.type === "ExportNamedDeclaration") {
      node = node.declaration;
      if (!node)
        continue;
    }
    if (node.type === "ImportDeclaration") {
      for (const specifier of node.specifiers)
        identifiers.add(specifier.local.name);
    } else if (node.type === "VariableDeclaration") {
      let handleVariableId = function(node2) {
        if (node2.type === "Identifier") {
          identifiers.add(node2.name);
        } else if (node2.type === "ObjectPattern") {
          for (const property of node2.properties) {
            if (property.type === "ObjectProperty")
              handleVariableId(property.value);
            else if (property.type === "RestElement" && property.argument.type === "Identifier")
              identifiers.add(property.argument.name);
          }
        } else if (node2.type === "ArrayPattern") {
          for (const element of node2.elements) {
            if ((element == null ? void 0 : element.type) === "Identifier")
              identifiers.add(element.name);
            else if ((element == null ? void 0 : element.type) === "RestElement" && element.argument.type === "Identifier")
              identifiers.add(element.argument.name);
            else if ((element == null ? void 0 : element.type) === "ObjectPattern" || (element == null ? void 0 : element.type) === "ArrayPattern")
              handleVariableId(element);
          }
        }
      };
      for (const declarator of node.declarations)
        handleVariableId(declarator.id);
    } else if (node.type === "FunctionDeclaration" || node.type === "ClassDeclaration") {
      if (node.id)
        identifiers.add(node.id.name);
    } else if (node.type === "TSEnumDeclaration") {
      if (node.id)
        identifiers.add(node.id.name);
    }
  }
  return identifiers;
}
function getIdentifierUsages(node, identifiers = new Set()) {
  if (!node)
    return identifiers;
  if (node.type === "BlockStatement") {
    node.body.forEach((child) => getIdentifierUsages(child, identifiers));
  } else if (node.type === "ExpressionStatement") {
    getIdentifierUsages(node.expression, identifiers);
  } else if (node.type === "Identifier") {
    identifiers.add(node.name);
  } else if (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") {
    getIdentifierUsages(node.object, identifiers);
  } else if (node.type === "CallExpression" || node.type === "OptionalCallExpression") {
    getIdentifierUsages(node.callee, identifiers);
    node.arguments.forEach((arg) => getIdentifierUsages(arg, identifiers));
  } else if (node.type === "BinaryExpression" || node.type === "LogicalExpression") {
    getIdentifierUsages(node.left, identifiers);
    getIdentifierUsages(node.right, identifiers);
  } else if (node.type === "UnaryExpression") {
    getIdentifierUsages(node.argument, identifiers);
  } else if (node.type === "ForOfStatement" || node.type === "ForInStatement") {
    getIdentifierUsages(node.right, identifiers);
  } else if (node.type === "ConditionalExpression") {
    getIdentifierUsages(node.test, identifiers);
    getIdentifierUsages(node.consequent, identifiers);
    getIdentifierUsages(node.alternate, identifiers);
  } else if (node.type === "ObjectExpression") {
    node.properties.forEach((prop) => {
      if (prop.type === "ObjectProperty") {
        if (prop.computed)
          getIdentifierUsages(prop.key, identifiers);
        getIdentifierUsages(prop.value, identifiers);
      } else if (prop.type === "SpreadElement") {
        getIdentifierUsages(prop, identifiers);
      }
    });
  } else if (node.type === "ArrayExpression") {
    node.elements.forEach((element) => getIdentifierUsages(element, identifiers));
  } else if (node.type === "SpreadElement" || node.type === "ReturnStatement") {
    getIdentifierUsages(node.argument, identifiers);
  } else if (node.type === "NewExpression") {
    getIdentifierUsages(node.callee, identifiers);
    node.arguments.forEach((arg) => getIdentifierUsages(arg, identifiers));
  } else if (node.type === "ArrowFunctionExpression" || node.type === "FunctionDeclaration" || node.type === "FunctionExpression") {
    getIdentifierUsages(node.body, identifiers);
  } else if (node.type === "TemplateLiteral") {
    node.expressions.forEach((expr) => getIdentifierUsages(expr, identifiers));
  }
  return identifiers;
}

// src/core/babel.ts
var _core = require('@babel/core');
var _parser = require('@babel/parser');

// src/core/parseSFC.ts
var multilineCommentsRE = /\/\*\s(.|[\r\n])*?\*\//gm;
var singlelineCommentsRE = /\/\/\s.*/g;
function parseSFC(code, id, options) {
  var _a, _b, _c, _d;
  const components = new Set();
  const expressions = new Set();
  const identifiers = new Set();
  let templateLevel = 0;
  let inScriptSetup = false;
  let inScript = false;
  const striped = code.replace(multilineCommentsRE, (r) => " ".repeat(r.length)).replace(singlelineCommentsRE, (r) => " ".repeat(r.length));
  const scriptSetup = {
    start: 0,
    end: 0,
    contentStart: 0,
    contentEnd: 0,
    content: "",
    attrs: {},
    found: false,
    ast: void 0
  };
  const script = {
    start: 0,
    end: 0,
    contentStart: 0,
    contentEnd: 0,
    content: "",
    attrs: {},
    found: false,
    ast: void 0
  };
  const htmlParserOptions = {
    xmlMode: true,
    lowerCaseTags: false,
    lowerCaseAttributeNames: false,
    recognizeSelfClosing: true
  };
  let pugStart;
  function handleTemplateContent(name, attributes) {
    if (!_shared.isHTMLTag.call(void 0, name) && !_shared.isSVGTag.call(void 0, name) && !_shared.isVoidTag.call(void 0, name))
      components.add(_shared.capitalize.call(void 0, _shared.camelize.call(void 0, name)));
    Object.entries(attributes).forEach(([key, value]) => {
      if (!value)
        return;
      if (key.startsWith("v-") || key.startsWith("@") || key.startsWith(":")) {
        if (key === "v-for")
          expressions.add(`(${value.replace(/^.*\s(?:in|of)\s/, "")})`);
        else
          expressions.add(`(${value})`);
      }
      if (key === "ref")
        identifiers.add(value);
    });
  }
  function handlePugTemplate(pugCode, id2) {
    try {
      const html = _chunkIEW4T7YPjs.__require.call(void 0, "pug").compile(pugCode, { filename: id2 })();
      const parser2 = new (0, _htmlparser2.Parser)({
        onopentag(name, attributes) {
          name && handleTemplateContent(name, attributes);
        }
      }, htmlParserOptions);
      parser2.write(html);
      parser2.end();
    } catch (e2) {
    }
  }
  const parser = new (0, _htmlparser2.Parser)({
    onopentag(name, attributes) {
      if (!name)
        return;
      if (name === "template") {
        if (templateLevel === 0 && attributes.lang === "pug")
          pugStart = parser.endIndex + 1;
        templateLevel += 1;
      }
      if (templateLevel > 0) {
        handleTemplateContent(name, attributes);
      } else {
        if (name === "script") {
          if ("setup" in attributes) {
            scriptSetup.start = parser.startIndex;
            scriptSetup.contentStart = parser.endIndex + 1;
            scriptSetup.attrs = attributes;
            scriptSetup.found = true;
            inScriptSetup = true;
          } else {
            script.start = parser.startIndex;
            script.contentStart = parser.endIndex + 1;
            script.attrs = attributes;
            script.found = true;
            inScript = true;
          }
        }
      }
    },
    ontext(text) {
      if (templateLevel > 0) {
        Array.from(text.matchAll(/\{\{(.*?)\}\}/g)).forEach(([, expression]) => {
          expressions.add(`(${expression})`);
        });
      }
    },
    onclosetag(name) {
      if (name === "template") {
        templateLevel -= 1;
        if (templateLevel === 0 && pugStart != null)
          handlePugTemplate(striped.slice(pugStart, parser.startIndex), id);
      }
      if (inScriptSetup && name === "script") {
        scriptSetup.end = parser.endIndex + 1;
        scriptSetup.contentEnd = parser.startIndex;
        scriptSetup.content = code.slice(scriptSetup.contentStart, scriptSetup.contentEnd);
        inScriptSetup = false;
      }
      if (inScript && name === "script") {
        script.end = parser.endIndex + 1;
        script.contentEnd = parser.startIndex;
        script.content = code.slice(script.contentStart, script.contentEnd);
        inScript = false;
      }
    }
  }, htmlParserOptions);
  parser.write(striped);
  parser.end();
  expressions.forEach((exp) => {
    const nodes = _parser.parse.call(void 0, exp).program.body;
    nodes.forEach((node) => getIdentifierUsages(node, identifiers));
  });
  if (script.found && scriptSetup.found && scriptSetup.attrs.lang !== script.attrs.lang)
    throw new SyntaxError("<script setup> language must be the same as <script>");
  const parserOptions = {
    sourceType: "module",
    plugins: []
  };
  const lang = scriptSetup.attrs.lang || script.attrs.lang || "js";
  if (lang === "ts")
    parserOptions.plugins.push("typescript");
  else if (lang === "jsx")
    parserOptions.plugins.push("jsx");
  else if (lang === "tsx")
    parserOptions.plugins.push("typescript", "jsx");
  else if (lang !== "js")
    throw new SyntaxError(`Unsupported script language: ${lang}`);
  scriptSetup.ast = _parser.parse.call(void 0, scriptSetup.content, parserOptions).program;
  script.ast = _parser.parse.call(void 0, script.content || "", parserOptions).program;
  scriptSetup.ast = ((_b = (_a = options == null ? void 0 : options.astTransforms) == null ? void 0 : _a.scriptSetup) == null ? void 0 : _b.call(_a, scriptSetup.ast)) || scriptSetup.ast;
  script.ast = ((_d = (_c = options == null ? void 0 : options.astTransforms) == null ? void 0 : _c.script) == null ? void 0 : _d.call(_c, script.ast)) || script.ast;
  return {
    id,
    template: {
      components,
      identifiers
    },
    scriptSetup,
    script,
    parserOptions,
    extraDeclarations: []
  };
}

// src/core/transformScriptSetup.ts

var _generator = require('@babel/generator'); var _generator2 = _interopRequireDefault(_generator);
var _utils = require('@antfu/utils');

// src/core/macros.ts
var DEFINE_PROPS = "defineProps";
var DEFINE_EMITS = "defineEmits";
var DEFINE_EXPOSE = "defineExpose";
var WITH_DEFAULTS = "withDefaults";
function applyMacros(nodes) {
  let hasDefinePropsCall = false;
  let hasDefineEmitCall = false;
  let propsRuntimeDecl;
  let propsRuntimeDefaults;
  let propsTypeDecl;
  let propsTypeDeclRaw;
  let emitsRuntimeDecl;
  let emitsTypeDecl;
  let emitsTypeDeclRaw;
  let exposeDecl;
  const typeDeclaredProps = {};
  const declaredTypes = {};
  function error(msg, node) {
    throw new Error(msg);
  }
  function processDefineProps(node) {
    if (!isCallOf(node, DEFINE_PROPS))
      return false;
    if (hasDefinePropsCall)
      error(`duplicate ${DEFINE_PROPS}() call`, node);
    hasDefinePropsCall = true;
    propsRuntimeDecl = node.arguments[0];
    if (node.typeParameters) {
      if (propsRuntimeDecl) {
        error(`${DEFINE_PROPS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
      }
      propsTypeDeclRaw = node.typeParameters.params[0];
      propsTypeDecl = resolveQualifiedType(propsTypeDeclRaw, (node2) => node2.type === "TSTypeLiteral");
      if (!propsTypeDecl) {
        error(`type argument passed to ${DEFINE_PROPS}() must be a literal type, or a reference to an interface or literal type.`, propsTypeDeclRaw);
      }
    }
    return true;
  }
  function processWithDefaults(node) {
    if (!isCallOf(node, WITH_DEFAULTS))
      return false;
    if (processDefineProps(node.arguments[0])) {
      if (propsRuntimeDecl) {
        error(`${WITH_DEFAULTS} can only be used with type-based ${DEFINE_PROPS} declaration.`, node);
      }
      propsRuntimeDefaults = node.arguments[1];
    } else {
      error(`${WITH_DEFAULTS}' first argument must be a ${DEFINE_PROPS} call.`, node.arguments[0] || node);
    }
    return true;
  }
  function processDefineEmits(node) {
    if (!isCallOf(node, DEFINE_EMITS))
      return false;
    if (hasDefineEmitCall)
      error(`duplicate ${DEFINE_EMITS}() call`, node);
    hasDefineEmitCall = true;
    emitsRuntimeDecl = node.arguments[0];
    if (node.typeParameters) {
      if (emitsRuntimeDecl) {
        error(`${DEFINE_EMITS}() cannot accept both type and non-type arguments at the same time. Use one or the other.`, node);
      }
      emitsTypeDeclRaw = node.typeParameters.params[0];
      emitsTypeDecl = resolveQualifiedType(emitsTypeDeclRaw, (node2) => node2.type === "TSFunctionType" || node2.type === "TSTypeLiteral");
      if (!emitsTypeDecl) {
        error(`type argument passed to ${DEFINE_EMITS}() must be a function type, a literal type with call signatures, or a reference to the above types.`, emitsTypeDeclRaw);
      }
    }
    return true;
  }
  function resolveQualifiedType(node, qualifier) {
    if (qualifier(node))
      return node;
    if (node.type === "TSTypeReference" && node.typeName.type === "Identifier") {
      const refName = node.typeName.name;
      const isQualifiedType = (node2) => {
        if (node2.type === "TSInterfaceDeclaration" && node2.id.name === refName)
          return node2.body;
        else if (node2.type === "TSTypeAliasDeclaration" && node2.id.name === refName && qualifier(node2.typeAnnotation))
          return node2.typeAnnotation;
        else if (node2.type === "ExportNamedDeclaration" && node2.declaration)
          return isQualifiedType(node2.declaration);
      };
      for (const node2 of nodes) {
        const qualified = isQualifiedType(node2);
        if (qualified)
          return qualified;
      }
    }
  }
  function processDefineExpose(node) {
    if (!isCallOf(node, DEFINE_EXPOSE))
      return false;
    if (exposeDecl)
      error(`duplicate ${DEFINE_EXPOSE}() call`, node);
    if (node.arguments.length !== 1)
      error(`${DEFINE_EXPOSE}() requires one argument`, node);
    exposeDecl = node.arguments[0];
    return true;
  }
  function genRuntimeProps(props) {
    const keys = Object.keys(props);
    if (!keys.length)
      return void 0;
    const hasStaticDefaults = propsRuntimeDefaults && propsRuntimeDefaults.type === "ObjectExpression" && propsRuntimeDefaults.properties.every((node) => node.type === "ObjectProperty" && !node.computed);
    return _core.types.objectExpression(Object.entries(props).map(([key, value]) => {
      const prop = hasStaticDefaults ? propsRuntimeDefaults.properties.find((node) => node.key.name === key) : void 0;
      if (prop)
        value.required = false;
      const entries = Object.entries(value).map(([key2, value2]) => key2 === "type" ? _core.types.objectProperty(_core.types.identifier(key2), typeof value2 === "string" ? _core.types.identifier(value2) : _core.types.arrayExpression(value2.map((i) => _core.types.identifier(i)))) : _core.types.objectProperty(_core.types.identifier(key2), _parser.parseExpression.call(void 0, JSON.stringify(value2))));
      if (prop)
        entries.push(_core.types.objectProperty(_core.types.identifier("default"), prop.value));
      return _core.types.objectProperty(_core.types.identifier(key), _core.types.objectExpression(entries));
    }));
  }
  function getProps() {
    if (propsRuntimeDecl)
      return propsRuntimeDecl;
    if (propsTypeDecl) {
      extractRuntimeProps(propsTypeDecl, typeDeclaredProps, declaredTypes);
      return genRuntimeProps(typeDeclaredProps);
    }
  }
  function throwIfAwait(node) {
    if (node.type === "AwaitExpression")
      error("top-level await is not supported in Vue 2", node);
  }
  nodes = nodes.map((raw) => {
    let node = raw;
    if (raw.type === "ExpressionStatement")
      node = raw.expression;
    if (node.type === "VariableDeclaration" && !node.declare) {
      const total = node.declarations.length;
      for (let i = 0; i < total; i++) {
        const decl = node.declarations[i];
        if (decl.init) {
          if (processDefineEmits(decl.init))
            decl.init = _core.types.memberExpression(_core.types.identifier("__ctx"), _core.types.identifier("emit"));
          else if (processDefineProps(decl.init) || processWithDefaults(decl.init))
            decl.init = _core.types.identifier("__props");
          else
            throwIfAwait(decl.init);
        }
      }
    }
    if (processWithDefaults(node) || processDefineEmits(node) || processDefineProps(node) || processDefineExpose(node))
      return null;
    throwIfAwait(node);
    return raw;
  }).filter(Boolean);
  return {
    nodes,
    props: getProps(),
    expose: exposeDecl
  };
}
function isCallOf(node, test) {
  return !!(node && node.type === "CallExpression" && node.callee.type === "Identifier" && (typeof test === "string" ? node.callee.name === test : test(node.callee.name)));
}
function extractRuntimeProps(node, props, declaredTypes) {
  const members = node.type === "TSTypeLiteral" ? node.members : node.body;
  for (const m of members) {
    if ((m.type === "TSPropertySignature" || m.type === "TSMethodSignature") && m.key.type === "Identifier") {
      let type;
      if (m.type === "TSMethodSignature") {
        type = ["Function"];
      } else if (m.typeAnnotation) {
        type = inferRuntimeType(m.typeAnnotation.typeAnnotation, declaredTypes);
      }
      props[m.key.name] = {
        key: m.key.name,
        required: !m.optional,
        type: (type == null ? void 0 : type.length) === 1 ? type[0] : type || "null"
      };
    }
  }
}
function inferRuntimeType(node, declaredTypes) {
  switch (node.type) {
    case "TSStringKeyword":
      return ["String"];
    case "TSNumberKeyword":
      return ["Number"];
    case "TSBooleanKeyword":
      return ["Boolean"];
    case "TSObjectKeyword":
      return ["Object"];
    case "TSTypeLiteral":
      return ["Object"];
    case "TSFunctionType":
      return ["Function"];
    case "TSArrayType":
    case "TSTupleType":
      return ["Array"];
    case "TSLiteralType":
      switch (node.literal.type) {
        case "StringLiteral":
          return ["String"];
        case "BooleanLiteral":
          return ["Boolean"];
        case "NumericLiteral":
        case "BigIntLiteral":
          return ["Number"];
        default:
          return ["null"];
      }
    case "TSTypeReference":
      if (node.typeName.type === "Identifier") {
        if (declaredTypes[node.typeName.name])
          return declaredTypes[node.typeName.name];
        switch (node.typeName.name) {
          case "Array":
          case "Function":
          case "Object":
          case "Set":
          case "Map":
          case "WeakSet":
          case "WeakMap":
            return [node.typeName.name];
          case "Record":
          case "Partial":
          case "Readonly":
          case "Pick":
          case "Omit":
          case "Exclude":
          case "Extract":
          case "Required":
          case "InstanceType":
            return ["Object"];
        }
      }
      return ["null"];
    case "TSParenthesizedType":
      return inferRuntimeType(node.typeAnnotation, declaredTypes);
    case "TSUnionType":
      return [
        ...new Set([].concat(...node.types.map((t2) => inferRuntimeType(t2, declaredTypes))))
      ];
    case "TSIntersectionType":
      return ["Object"];
    default:
      return ["null"];
  }
}

// src/core/transformScriptSetup.ts
function isAsyncImport(node) {
  var _a, _b;
  if (node.type === "VariableDeclaration") {
    const declaration = node.declarations[0];
    return ((_b = (_a = declaration == null ? void 0 : declaration.init) == null ? void 0 : _a.callee) == null ? void 0 : _b.name) === "defineAsyncComponent";
  }
  return false;
}
function transformScriptSetup(sfc, options) {
  var _a, _b;
  const { scriptSetup, script, template } = sfc;
  const { nodes: body, props, expose } = applyMacros(scriptSetup.ast.body);
  const [hoisted, setupBody] = _utils.partition.call(void 0, body, (n) => isAsyncImport(n) || n.type === "ImportDeclaration" || n.type === "ExportNamedDeclaration" || n.type.startsWith("TS"));
  const declarations = new Set();
  getIdentifierDeclarations(hoisted, declarations);
  getIdentifierDeclarations(setupBody, declarations);
  const returns = Array.from(declarations).filter(Boolean).filter((i) => template.identifiers.has(i)).map((i) => {
    const id = _core.types.identifier(i);
    return _core.types.objectProperty(id, id, false, true);
  });
  const components = Array.from(declarations).filter(Boolean).filter((i) => template.components.has(i) || template.components.has(_shared.camelize.call(void 0, i)) || template.components.has(_shared.capitalize.call(void 0, _shared.camelize.call(void 0, i))));
  const __sfc = _core.types.identifier("__sfc_main");
  let hasBody = false;
  const bodyNodes = script.ast.body.map((node) => {
    if (node.type === "ExportDefaultDeclaration") {
      hasBody = true;
      return _core.types.variableDeclaration("const", [
        _core.types.variableDeclarator(__sfc, node.declaration)
      ]);
    }
    return node;
  });
  let ast = _core.types.program([
    ...sfc.extraDeclarations,
    ...hoisted,
    ...bodyNodes
  ]);
  if (!hasBody) {
    ast.body.push(_core.types.variableDeclaration("const", [
      _core.types.variableDeclarator(__sfc, _core.types.objectExpression([]))
    ]));
  }
  if (props) {
    hasBody = true;
    ast.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(__sfc, _core.types.identifier("props")), props)));
  }
  if (body.length) {
    hasBody = true;
    const returnExpr = expose ? _core.types.callExpression(_core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")), [_core.types.objectExpression(returns), expose]) : _core.types.objectExpression(returns);
    const returnStatement = _core.types.returnStatement(returnExpr);
    ast.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(__sfc, _core.types.identifier("setup")), _core.types.arrowFunctionExpression([
      _core.types.identifier("__props"),
      _core.types.identifier("__ctx")
    ], _core.types.blockStatement([
      ...setupBody,
      returnStatement
    ])))));
  }
  if (components.length) {
    hasBody = true;
    const componentsObject = _core.types.objectExpression(components.map((i) => {
      const id = _core.types.identifier(i);
      return _core.types.objectProperty(id, id, false, true);
    }));
    ast.body.push(_core.types.expressionStatement(_core.types.assignmentExpression("=", _core.types.memberExpression(__sfc, _core.types.identifier("components")), _core.types.callExpression(_core.types.memberExpression(_core.types.identifier("Object"), _core.types.identifier("assign")), [
      componentsObject,
      _core.types.memberExpression(__sfc, _core.types.identifier("components"))
    ]))));
  }
  if (!hasBody && !(options == null ? void 0 : options.astTransforms)) {
    return {
      ast: null,
      code: ""
    };
  }
  ast.body.push(_core.types.exportDefaultDeclaration(__sfc));
  ast = ((_b = (_a = options == null ? void 0 : options.astTransforms) == null ? void 0 : _a.post) == null ? void 0 : _b.call(_a, ast, sfc)) || ast;
  return {
    ast,
    code: _generator2.default.call(void 0, ast).code
  };
}

// src/core/transformSfcRefSugar.ts


function transformSfcRefSugar(sfc, options) {
  const importedHelpers = new Set();
  for (const script of [sfc.script, sfc.scriptSetup]) {
    if (_reftransform.shouldTransform.call(void 0, script.content)) {
      const s = new (0, _magicstring2.default)(script.content);
      const { importedHelpers: imports } = _reftransform.transformAST.call(void 0, script.ast, s);
      Array.from(imports).forEach((helper) => importedHelpers.add(helper));
      script.content = s.toString();
      script.ast = _parser.parse.call(void 0, script.content, sfc.parserOptions).program;
    }
  }
  if (importedHelpers.size) {
    sfc.extraDeclarations = [
      _core.types.importDeclaration(Array.from(importedHelpers).map((i) => _core.types.importSpecifier(_core.types.identifier(`_${i}`), _core.types.identifier(i))), _core.types.stringLiteral(options.importHelpersFrom))
    ];
  }
}

// src/core/options.ts
function resolveOptions(options = {}) {
  return Object.assign({}, {
    sourceMap: true,
    refTransform: false,
    importHelpersFrom: "@vue/composition-api",
    astTransforms: {}
  }, options);
}

// src/core/transform.ts
var scriptSetupRE = /<script\s(.*\s)?setup(\s.*)?>/;
function shouldTransform2(code, id, options) {
  if (code.includes("export default __sfc_main"))
    return false;
  return (options == null ? void 0 : options.refTransform) && _reftransform.shouldTransform.call(void 0, code) || scriptSetupRE.test(code);
}
function transform(input, id, options) {
  if (!shouldTransform2(input, id, options))
    return null;
  const resolved = resolveOptions(options);
  if (id.endsWith(".vue") || id.includes(".vue?vue"))
    return transformVue(input, id, resolved);
  else
    return transformNonVue(input, id, resolved);
}
function transformNonVue(input, id, options) {
  if (options.refTransform && _reftransform.shouldTransform.call(void 0, input)) {
    return _reftransform.transform.call(void 0, input, {
      filename: id,
      sourceMap: options.sourceMap,
      importHelpersFrom: options.importHelpersFrom
    });
  }
  return null;
}
function transformVue(input, id, options) {
  const s = new (0, _magicstring2.default)(input);
  const sfc = parseSFC(input, id);
  if (options.refTransform)
    transformSfcRefSugar(sfc, options);
  const { code } = transformScriptSetup(sfc, options);
  const attributes = _chunkIEW4T7YPjs.__spreadValues.call(void 0, _chunkIEW4T7YPjs.__spreadValues.call(void 0, {}, sfc.script.attrs), sfc.scriptSetup.attrs);
  delete attributes.setup;
  const attr = Object.entries(attributes).map(([key, value]) => value ? `${key}="${value}"` : key).join(" ");
  if (code) {
    const block = `<script ${attr}>
${code}
<\/script>`;
    s.remove(sfc.script.start, sfc.script.end);
    if (sfc.scriptSetup.start !== sfc.scriptSetup.end) {
      s.overwrite(sfc.scriptSetup.start, sfc.scriptSetup.end, block);
    } else {
      s.prependLeft(0, `${block}
`);
    }
  }
  return {
    code: s.toString(),
    map: options.sourceMap ? s.generateMap({
      source: id,
      includeContent: true
    }) : null
  };
}

// src/index.ts
var unplugin = _unplugin.createUnplugin.call(void 0, (options = {}) => {
  const filter = _pluginutils.createFilter.call(void 0, options.include || (options.refTransform ? [/\.vue$/, /\.vue\?vue/, /\.[jt]sx?$/] : [/\.vue$/, /\.vue\?vue/]), options.exclude || [/node_modules/, /\.git/, /\.nuxt/]);
  return {
    name: "unplugin-vue2-script-setup",
    enforce: "pre",
    transformInclude(id) {
      return filter(id);
    },
    transform(code, id) {
      try {
        return transform(code, id, options);
      } catch (e) {
        this.error(e);
      }
    }
  };
});
var src_default = unplugin;







exports.transformScriptSetup = transformScriptSetup; exports.shouldTransform = shouldTransform2; exports.transform = transform; exports.unplugin = unplugin; exports.src_default = src_default;
