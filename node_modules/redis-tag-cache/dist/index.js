'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ioredis = require('ioredis');

var _ioredis2 = _interopRequireDefault(_ioredis);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class TagCache {

  constructor(options = {}) {
    _initialiseProps.call(this);

    this.redis = new _ioredis2.default(options.redis || {});
    this.options = options;
  }

  // How invalidation by tag works:
  // 1. Get all the keys associated with all the passed-in tags (tags:${tag})
  // 2. Delete all the keys data (data:${key})
  // 3. Delete all the tags (tags:${tag})
} /*  strict
   *
   * TagCache
   * Allows one to cache data with tags and invalidate based on them
   *
   * Under the hood this stores one set of keys per tag (ID) and the data per key in Redis:
   * - `tags:asdf-123` = `db.table('threads').get('asdf-345') db.table('threads').get('asdf-234') ...`
   * - `data:db.table('threads').get('asdf-345')` = `{ "id": "asdf-345", "content": { "title": "Hello" }, ... }`
   */

var _initialiseProps = function () {
  this.get = async (...keys) => {
    try {
      return this.redis.mget(keys.map(key => `data:${key}`)).then(res => {
        try {
          // Special case for single element gets
          if (res.length === 1) return JSON.parse(res[0]);
          return res.map(elem => JSON.parse(elem));
        } catch (err) {
          return res;
        }
      });
    } catch (err) {
      return Promise.reject(err);
    }
  };

  this.set = async (key, data, tags, options = {}) => {
    try {
      // NOTE(@mxstbr): This is a multi execution because if any of the commands is invalid
      // we don't want to execute anything
      const multi = await this.redis.multi();

      // Add the key to each of the tag sets
      tags.forEach(tag => {
        multi.sadd(`tags:${tag}`, key);
      });

      const timeout = options && options.timeout || this.options.defaultTimeout;
      // Add the data to the key
      if (typeof timeout === 'number') {
        multi.set(`data:${key}`, JSON.stringify(data), 'ex', timeout);
      } else {
        multi.set(`data:${key}`, JSON.stringify(data));
      }
      await multi.exec();
      return;
    } catch (err) {
      return Promise.reject(err);
    }
  };

  this.invalidate = async (...tags) => {
    try {
      // NOTE(@mxstbr): [].concat.apply([],...) flattens the array
      const keys = [].concat.apply([], (await Promise.all(tags.map(tag => this.redis.smembers(`tags:${tag}`)))));

      const pipeline = await this.redis.pipeline();

      keys.forEach(key => {
        pipeline.del(`data:${key}`);
      });

      tags.forEach(tag => {
        pipeline.del(`tags:${tag}`);
      });

      await pipeline.exec();
    } catch (err) {
      return Promise.reject(err);
    }
  };
};

exports.default = TagCache;